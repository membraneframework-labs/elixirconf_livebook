# Creating Jellyfish conference

## Resources

TODO

## Setup Jellyfish

Start by getting Jellyfish serer up and running

First, let's create `.env` file with env vars for Jellyfish

```.env
# used by the server e.g. to create tokens
SECRET_KEY_BASE=super-secret-key

# true, if WebRTC peers are used
WEBRTC_USED=true

# hostname used to generate URLs through the server
VIRTUAL_HOST=localhost
PORT=5000

# Token used by the backend to connect to the server
TOKEN=notoken

# TURN default configuration
# note: loopback address as INTEGRATED_TURN_IP cannot be used inside a Docker container
INTEGRATED_TURN_IP=<PUT YOUR MACHINE IP HERE>
INTEGRATED_TURN_PORT_RANGE=50000-50050
INTEGRATED_TCP_TURN_PORT=49999
```

Getting your machine IP

```bash
# Linux
ip addr show

# macOS
ifconfig en0
```

### Using Docker

Then run

```bash
docker run --env-file .env -p 50000-50050:50000-50050/udp -p 5000:5000/tcp -p 49999:49999/tcp ghcr.io/jellyfish-dev/jellyfish:latest
```

### Run locally

Follow: https://jellyfish-dev.github.io/jellyfish-docs/getting_started/installation

### Result

You should be able to query Jellyfish:

```bash
$ curl localhost:5000
{"errors":{"detail":"Not Found"}}
```

## Setup Phoenix backend

Let's create a Phoenix app with our buisness logic. Once again we'll start with Phoenix generator with following flags

```bash
mix phx.new --no-ecto --no-live --no-mailer --no-gettext jellyroom
```

Add Jellyfish SDK to Elixir deps in `mix.exs`:

<!-- livebook:{"force_markdown":true} -->

```elixir
{:jellyfish_server_sdk, "~> 0.1.0"},
```

Go to assets directory and install Jellyfish JS dependencies:

```bash
npm install jellyfish-dev/jellyfish-react-client/jellyfish#main --save
```

Now we're ready to start development of our own videoconferencing app.

## Client to backend connection

We'll start by setting up our frontend to backend connection and calling Jellyfish API. Our goal will be to obtain a token associated with a room and peer that frontend can use to establish a direct connection to Jellyfish.

Later on, we'll build architecture managing the rooms and peers on our backend, but we'll start with something much simpler:

1. For authorization, we'll need to setup the same secret/token as passed to the Jellyfish. I'd suggest setting it in `config.exs`, but it can be hard-coded for now.
2. Create a new [`Phoenix.Channel`](https://hexdocs.pm/phoenix/channels.html)
3. On join, send messsage to self and let the user join.
4. Handle the message sent above and create a new [`Jellyfish.Client`](https://hexdocs.pm/jellyfish_server_sdk/Jellyfish.Client.html) and use it to create a new [`Jellyfish.Room`](https://hexdocs.pm/jellyfish_server_sdk/Jellyfish.Room.html). Then add a new `webtrc` peer to the room. Remember to assign client, room and the peer to the socket.
5. From the above callback push the token over socket
6. We should be handling termination of the room - we will handle it better later, for now we may add a simple process monitoring channel's process calling `Room.delete` on channel exit.
7. Go to the JS part of the channel and handle the token message.

## Frontend - let's send some media to Jellyfish

The next step is to use the obtained token to start sending media to Jellyfish. We're going to use JS WebRTC APIs and [Jellyfish TS client](https://github.com/jellyfish-dev/jellyfish-react-client/blob/update-readme/src/jellyfish/readme.md).

## Room management

It is now time to get back to our backend. We need to build an infrastructure around rooms to enable connecting the peers.

1. Add a registry to `application.exs`
2. Create a `GenServer` called `Meeting` responsible for creating Jellyfish room. API:
   * A function for getting a room from registry or spawning a new one if it doesn't exist
   * Should get a name as a starting parameter and use it as a key to register in the Registry
   * Create a room right after start (`handle_continue`)
   * Accept a call for room join that will return a token and monitor the caller
   * Notify the peers about new peers joining
   * TODO: continue
3. Create a form at root path to input room name and redirect to `/room/:name`
4. Add a layout for `/room/:name` path
5. Adjust Channel to spawn or call the room process based on registry
